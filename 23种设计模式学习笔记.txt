23种设计模式学习笔记：

三大类：
一、创建型模式5

二、结构型模式7

三、行为型模式11



开闭原则：对于扩展是开放的，但是对于修改是封闭的。
一个实体、不改变它的源代码的情况下改变它的行为。  源代码？ 行为？
使用 继承 来解决
多态开闭原则： 抽象基类的继承。
新的需求，面向接口编程、或者叫做面向抽象编程。
所有的 参数类型、引用类型

abstract和Virtual：
Virtual有实现、重写执行重写
abstract 无实现、调用需重写。

我将基类窗体进行了抽象，导致是子窗体的设计器全部失效，报的错误是无法获取到子类的实例。

这可能跟这个编译器有点关系，因为VS的一个窗口，可能是该窗体类的一个实例，调用了Drawing函数，实际画出了一个展示的窗体，然后在通过拖拽的方式设计窗体的时候，同步修改了Designer里面的代码。其实仍旧是通过Designer实例化来Drawing出来的效果。

所以如果将基类抽象化，我需要重写才能实例化子类。而我这里没有重写，所以编译可以通过，但是无法实例化并Drawing出子窗体。

测试：将baseForm抽象，并调试程序，如果程序正常运行证明猜想成立。
调试成功，猜想成立。 所以这个baseForm可以用接口的形式来表现？
可以进行拆分吧，一部分接口，一部分基类。
但是基类是避免不了继承Form的，为什么？因为他的子类都是Form。

那么我为什么不直接用一个Helper什么的呢。

也是可以的。但是吧目前没有重构的必要。

后面设计程序的时候再看一下吧。

在我的程序中没有使用到接口的位置，其实照理来说应该都是很多地方是有接口的，之前阳哥有用一个SaveData()，但是是使用基类的继承的方式来调用子类的SaveData函数，这个设计没有好好利用，应该方便我调用base.savedata应该才是比较好的。那么如果这个地方改成接口怎么样呢？应该说非常完美吧。需要的就继承这个接口，不需要的就不继承。

然后我还有一个继承的是 m_Current...  这一个类用来储存了当前的prjGuid、审查阶段、还有一系列信息，但是有些地方可能并不需要一些成员。接口隔离原则吗？（应该不，：每个接口中不存在子类用不到却必须实现的方法，这个只是个属性，不是方法，也没有必须实现。）
我储存了两个地市,一个是从本地读取跟随lockNum一起放在了UserInfo下面、一个是选择项目所在地市的时候，放在了baseForm下面。

这个正常吗？ 如果放在Current里面合理吗？ 那个是单个项目，应该是先有地市再有项目再有单个项目。所以放在Current里面并不合理，并不是所有的baseForm的基类都会去设置CityNum，但是使用有可能都会使用到。
谁创建，谁设置？

接口、返回的可以是定义的接口类型
，然后直接调用基类.函数()；具体的子类不用管。（工厂模式）
感觉我重构的eiService，在调用静态的DbHelper.qmiDbHelper的时候就使用了静态工厂模式。不过我是直接调用，但是他是实例化，因为他的函数并不是一个静态的函数。
如果我现在有三个库，而不是sys和qmi库了这么办？ 我就必须要修改dbHelper，需要新增DbType吗，不需要。需要的是在里面添加一个 静态otherDbHelper的构造函数。 但是这个确实是违反了闭包原则（对原来的DbHelper类进行了修改），所以应该使用接口，将DbHelper定义成一个接口，然后返回对应不同类型数据库为单独的类继承接口DbHelper。
其实我的设计是合理的，但是讲到扩展的话，是不合理的。也就是对类的分类并没有那么细致。

为什么三种数据库的连接方式叫做Factory，这有点意思，这应该就是工厂模式。
他是用什么来区分的？ Provider 然后在配置文件会有一些配置。
他是在Factory里面做了处理。
0.2多个方法：如果我要重新实现三种数据库的，我需要添加接口。接口封装用于执行
然后Factory，用Factory来控制三种数据库的实例化。
最后在程序中用Factory实例化出来的接口来执行语句。

0.3多个静态方法：将工厂里的方法改为静态。不需要实例化工厂直接调用。

continue 
1.工厂方法模式：为了在拓展的时候，不对工厂类进行修改。直接新增工厂类，而不是修改之前的工厂类。做个实现类、实现Sender接口，做一个工厂类实现Provider。
两个接口，一个是之前的Sender，提供Send函数。新增Provider接口，提供函数produce，实例化具体的工厂，实例化具体的Sender调用Send

2.抽象工厂和工厂方法。抽象工厂在乎工厂，工厂方法在乎生产线。

3.单例模式
   平时少了一个序列化函数
    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  
    public Object readResolve() {  
        return instance;  
    }  
3.1单例模式的多线程应对：具体问题具体分析吧。有个相对完美的创建模板。

4.建造者模式

5.原形模式
将一个具体的对象作为原型，对其进行复制、克隆
（深度克隆和浅度克隆）

01.类的适配器模式
Source ->Target
中间的 Adapter
Adapter extends Source 实现接口 Target 
adapter.SourceMethond1();
adapter.SourceMethond2();
两个方法1相同，适配器继承源和实现接口Target

02.对象的适配器模式
接口目标，Wrapper将Source类包装，然后两个函数实现 source.method();
targetable.method();

03.在接口抽象方法太多，有一些冗余的抽象方法的时候使用。
interface Sourceable有两个函数
使用*抽象类Wrapper2
abstract Wrapper2 implements Sourceable 
然后再使用两个类来继承Wrapper2
分别实现其函数1，函数2

7.装饰模式（Decorator）
动态给对象增加一些新的功能
应用环境：
1.需要扩展一个类的功能。
2.动态为一个对象增加功能，还能动态撤销。 

首先定义共同的接口Sourceable
Source实现接口

将source传入到Decorator，在接口函数里面实现source.method()(源函数);
再实现装饰上的new.method();（这个method是动态加上去的）。


8.代理模式（Proxy）
应用场景：对结果进行控制，可以将功能划分更加清晰，有助后期维护。
源类继承接口
代理继承接口同时内部实例化源，
代理实现接口函数method的时候，调用源method，这样就可以对源method的结果进行控制了。
测试类实例化代理调用method即可。

9.外观模式
没有设计到接口。
为了减少依赖和耦合度而已。

10.桥接模式
应用场景：定义与实现分离。 
两个实现类，Source1,Source2
然后定义桥Bridge.
桥拥有接口实例，然后调用的时候，分别set桥的实例最后来调用不同的接口方法。

11.组合模式

 



















